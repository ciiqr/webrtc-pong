<!doctype html>
<meta charset="utf-8">

<div id=box1>
<h3>Create or join a room?</h3>
<button id="createBtn">BOB: Create</button><p>
<button id="joinBtn1">ALICE: Join</button>
</div>

<form id=box2 style='display:none;'>
Enter ID: <input id="conid">
<button id="joinBtn2">Join</button>
</form>

<div id=box3 style='display:block'>

<br>
<canvas id=game style="border:1px solid" width=800 height=600></canvas>
<br>


<pre id=stats></pre>
<canvas id=graph style="border:1px solid" width=800 height=400></canvas>
</div>

<script src=DC.js></script>
<script>
canvas=document.getElementById("game")
ctx=canvas.getContext("2d")
w=canvas.width;h=canvas.height

graph=document.getElementById("graph").getContext("2d")

host=false;
connected=false;
bufferSize = 3;
frameNumber = -bufferSize;

driftThreshold = 1 //ms
driftTrimFactor = 0.1 //
stacksize=5 // averaging period for ping/lead times

frameLength = 1000/60 //60FPS target
nextFrame=0

myInputs=[]
yoInputs=[]

paddleH=60
left={Y:h/2}
right={Y:h/2}
grabY = 0; //mouse input

// Animation frame FPS could be different at each end, so don't rely on it for any timing.
draw=function(){
  ctx.clearRect( 0,0,w,h)
  ctx.fillRect( 10, left.Y - paddleH/2, 20, paddleH)
  ctx.fillRect( w-30, right.Y - paddleH/2, 20, paddleH)

  doStats()
  if (connected) requestAnimationFrame(draw)
}




timePair={t1:null,t2:null} // of last received packet
pingStack=[]
leadStack=[]
function send(o){
  o.t1 = timePair.t1
  o.t2 = timePair.t2
  o.tSend=performance.now()
  DC.send(o)
}
function avg(a){
  return a.reduce((x,y)=>x+y)/a.length
}

setup = {
  onopen: function(){
    console.log('[ connected ]');
    connected=true;
    requestAnimationFrame(draw)
    box1.style.display='none';
    box2.style.display='none';
    box3.style.display='block';

    if (host) {
      send({type:"SYN"})
    }
  },
  onclose: function(){
    connected=false;
    console.log('[ disconnected ]')

  },
  onmessage:function(e) {
    let ping, recTime = performance.now()
    var data = JSON.parse(e.data)
    timePair = {t1:data.tSend, t2:recTime}

    if (data.t1) {
      let t1=data.t1, t2=data.t2, t3=data.tSend, t4 = recTime;
      ping = t4-t1 - (t3-t2);
      pingStack.push(ping)
      if (pingStack.length>stacksize) pingStack.shift()
    }

    if (data.type) switch (data.type) {
      case "SYN":
        send({type:"SYNACK"})
        break;
      case "SYNACK":
        // repeatedly send start condition to establish average ping time
        if (pingStack.length < stacksize) send({type:"SYN"})
        else {
          pingStack.shift() // The first is usually unrepresentative, throw away
          send({type:"ACK"})

          // wait for half the roundtrip time before starting the first frame
          nextFrame = performance.now() + avg(pingStack)/2
          setTimeout(processFrame, nextFrame - performance.now())
        }
        break;
      case "ACK":
        nextFrame = performance.now()
        processFrame()
        break;
      case "input":
        yoInputs.push(data.input)

        // check/adjust timing
        //input packet contains estimate until next frame
        let otherNextFrame = recTime -ping/2 + data.delay
        let frameDifference = (frameNumber-1 -data.input.frame)*frameLength
        let leadTime = nextFrame - otherNextFrame - frameDifference;
        leadStack.push(leadTime)
        if (leadStack.length>stacksize) leadStack.shift()

        break;
    }
  }
}

keymap={38:0,40:0}
document.onkeydown=function(e){keymap[e.keyCode]=1}
document.onkeyup  =function(e){keymap[e.keyCode]=0}

for (let i=0;i<bufferSize;i++) {
  myInputs.push( { frame:frameNumber, dir:0 } )
  yoInputs.push( { frame:frameNumber, dir:0 } )
  frameNumber++
}
function processFrame(){

  // if yoInputs buffer empty, we need to explicitly delay
  if (yoInputs.length==0) {
    console.log("input buffer empty!!")
    nextFrame += 1
    if (connected) setTimeout(processFrame,1)
    return
  }

  // consume inputs from stack, recalculate game
  let myInput = myInputs.shift()
  let yoInput = yoInputs.shift()

  if (myInput.frame != yoInput.frame) {console.log("SYNC ERROR AHHH", myInput,yoInput); return}

  if (host) { processPlayer(left, myInput); processPlayer(right, yoInput); }
  else      { processPlayer(left, yoInput); processPlayer(right, myInput); }

  // calculate ball and stuff


  // take input from keyboard and add to stack
  myinput = { frame:frameNumber, dir:grabY }
  grabY = 0;
  myInputs.push( myinput )


  // timing drift correction - should this be before or after transmitting?
  if (leadStack.length==stacksize) {
    let lead = -avg(leadStack)
    if (lead>driftThreshold) { //we are running fast
       nextFrame += Math.min(lead*driftTrimFactor, frameLength)
    }
  }

  frameNumber++
  nextFrame += frameLength

  let now = performance.now()
  if (nextFrame<now) {
    console.log('timing disrupted')
    nextFrame=now
  }
  let delay = nextFrame - now

  // send inputs to other
  send({type:"input", input:myinput, delay})


  if (connected) setTimeout(processFrame, delay )
}

function processPlayer(p, input){
  p.Y += input.dir;
  if (p.Y > h-paddleH) p.Y = h-paddleH;
  if (p.Y <   paddleH) p.Y = paddleH;
}

createBtn.onclick = function() {
  box1.innerHTML = '<h3>ID: '+ DC.host( setup ) +'</h3>';
  host=true;
}

joinBtn1.onclick = function(){
  box2.style.display='block'
  box1.style.display='none'
  conid.focus()
}
joinBtn2.onclick = function(){
  DC.join( parseInt(conid.value), setup );
  box2.innerHTML='Connecting...'
  return false
}

conid.value = "";



canvas.onmousedown=function(e){
  let sy = e.pageY
  e.preventDefault()
  e.stopPropagation()

  document.onmousemove=function(e){
    grabY += e.pageY - sy
    sy = e.pageY
  }
  document.onmouseup=function(e){
    document.onmouseup=null;
    document.onmousemove=null;
  }
}





function newGraph(pos, col){
  var lastY=0;
  return function( y ){
    graph.strokeStyle=col
    graph.beginPath()
    graph.moveTo(needle-1,lastY +pos)
    graph.lineTo(needle,y +pos)
    graph.stroke()
    lastY=y
  }
}

needle=0
plotLead = newGraph(100,"green")
plotBuff = newGraph(200,"blue")
plotPing = newGraph(380, "red")
function doStats(){
  let lead = leadStack.length? avg(leadStack) : 0;
  let ping = pingStack.length? avg(pingStack) : 0;

  graph.clearRect(needle,0,3,400)

  graph.strokeStyle="#888"
  graph.beginPath()
  graph.moveTo(needle-1,100)
  graph.lineTo(needle,  100)
  graph.moveTo(needle-1,200)
  graph.lineTo(needle,  200)
  graph.moveTo(needle-1,200-bufferSize*5)
  graph.lineTo(needle,  200-bufferSize*5)
  graph.moveTo(needle-1,380)
  graph.lineTo(needle,  380)
  graph.stroke()

  plotPing(-ping)
  plotBuff(-yoInputs.length*5)
  plotLead(lead)

  if (++needle>=800) needle=0


  let p="ping: " +ping.toFixed(3) + "ms\n"
       +"lead: " +lead.toFixed(3) + "ms\n"
       +"buffer: "+"\u25ae".repeat(yoInputs.length);
  if (yoInputs.length<bufferSize) p+="\u25af".repeat(bufferSize-yoInputs.length)
  document.getElementById("stats").innerHTML = p
}



</script>