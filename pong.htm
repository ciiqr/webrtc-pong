<!doctype html>
<meta charset="utf-8">

<div id=box1>
<button id="createBtn">Create Game</button><p>
<button id="joinBtn1">Join Game</button>
</div>

<form id=box2 style='display:none;padding:20px;'>
Enter ID: <input id="conid">
<button id="joinBtn2">Join</button>
</form>

<div id=box3 style='display:none'>
 <label><input type=checkbox id=showstats oninput="showstats=this.checked;statsbox.style.display=showstats?'block':'none'"> Show stats</label>
 <label><input type=checkbox id=enablesynctick oninput="enablesynctick=this.checked;synctick=0" checked> synctick</label>
 <div style="position:relative">
  <div id=statsbox>
   <pre id=stats style="position:absolute;top:10px;left:50px;"></pre>
   <canvas id=ggrid style="position:absolute;" width=800 height=600></canvas>
   <canvas id=graph style="position:absolute;" width=800 height=600></canvas>
  </div>
  <canvas id=game style="border:1px solid;position:absolute" width=800 height=600></canvas>
 </div>
</div>

<script src=DC.js></script>
<script>
canvas=document.getElementById("game")
ctx=canvas.getContext("2d")
ctx.imageSmoothingEnabled=false;
w=canvas.width;h=canvas.height

graph=document.getElementById("graph").getContext("2d")
ggrid=document.getElementById("ggrid").getContext("2d")
showstats=document.getElementById("showstats").checked;
statsbox.style.display=showstats?'block':'none';

enablesynctick=document.getElementById("enablesynctick").checked;

host=false;
connected=false;
bufferSize = 4;
frameNumber = -bufferSize;

driftThreshold = 1 //ms
driftTrimFactor = 0.1 //
stacksize=5 // averaging period for ping/lead times

frameLength = 1000/60 //1000/FPS target
nextFrame=0
lastAnimationFrame=0;
animFrameRate=0; // measured animation frame rate, not target
animFrameRateSample=0;
animFrameRateCount=0;
synctick=0;


myInputs=[]
yoInputs=[]
rollbackState={}
rollbackInputs=[]
yoInputLastDir=0;

paddleH=60
paddleW=20
ballSize=20
edgeGuard=paddleH/2+ballSize/2
left ={y:h/2,x:20}
right={y:h/2,x:w-20}
grabY = 0; //mouse input

scoreLeft=0
scoreRight=0

ball={x:0,y:0,speed:0,hspeed:0,vspeed:0}

function storeRollbackState(){
  rollbackState = {frame:myInputs[0].frame, seed, scoreLeft, scoreRight, ball:objcopy(ball), leftY:left.y, rightY:right.y}
}
function loadRollbackState(){
  left.y=rollbackState.leftY
  right.y=rollbackState.rightY
  seed=rollbackState.seed
  scoreLeft=rollbackState.scoreLeft
  scoreRight=rollbackState.scoreRight
  ball=objcopy(rollbackState.ball)
}


// Animation frame FPS could be different at each end, so don't rely on it for any timing.
draw=function(t){
  animFrameRateCount+=(t-lastAnimationFrame);
  if (++animFrameRateSample >= 18) {
    animFrameRate = 18*1000/animFrameRateCount
    animFrameRateCount=0
    animFrameRateSample=0
  }

  lastAnimationFrame=t

  ctx.clearRect( 0,0,w,h)
  ctx.fillRect( left.x - paddleW/2, left.y - paddleH/2, paddleW, paddleH)
  ctx.fillRect( right.x - paddleW/2, right.y - paddleH/2, paddleW, paddleH)
  ctx.fillRect( ball.x-ballSize/2,ball.y-ballSize/2, ballSize, ballSize )

  if (!showstats) {
    for (let i=13;i<h;i+=27) ctx.fillRect( w/2-5,i, 10,10)
    drawScore(w/2-45,scoreLeft,1)
    drawScore(w/2+55,scoreRight)
  } else doStats(t)

  if (connected) requestAnimationFrame(draw)
}
var font=new Image();
font.src="data:image/gif;base64,R0lGODlhHgAFAIABAAAAAP///yH5BAEAAAEALAAAAAAeAAUAAAIdhANom+x/WphJWTRp23h7WIEdloUaGWnpozItVQAAOw==";

function drawScore(x,s,a){
  let t=s.toString(), off=a?t.length*40:0;
  for (var c in t) {
    ctx.drawImage(font, (t[c].charCodeAt(0)-0x30)*3, 0, 3,5,x+c*40-off,20,30,50)
  }
}

seed= Math.floor(Math.random()*0xFFFFFFFF);
function rng() {
  var t = seed += 0x6D2B79F5;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}

function resetBall(){
  // choose a random angle in a 90deg cone facing one of the players
  let angle, pi=Math.PI;
  angle= rng()*pi/2-pi/4;
  if (rng()>0.5) angle+=pi;

  ball.x=w/2
  ball.y=h/2
  ball.speed=4
  ball.hspeed = Math.cos(angle)*ball.speed
  ball.vspeed = Math.sin(angle)*ball.speed
}


timePair={t1:null,t2:null} // of last received packet
pingStack=[]
leadStack=[]
function send(o){
  o.t1 = timePair.t1
  o.t2 = timePair.t2
  o.tSend=performance.now()
  DC.send(o)
}
function avg(a){
  return a.reduce((x,y)=>x+y)/a.length
}

setup = {
  onopen: function(){
    console.log('[ connected ]');
    connected=true;
    requestAnimationFrame(draw)
    box1.style.display='none';
    box2.style.display='none';
    box3.style.display='block';

    if (host) {
      send({type:"SYN"})
    }
  },
  onclose: function(){
    connected=false;
    console.log('[ disconnected ]')

  },
  onmessage:function(e) {
    let ping, recTime = performance.now()
    var data = JSON.parse(e.data)
    timePair = {t1:data.tSend, t2:recTime}

    if (data.t1) {
      let t1=data.t1, t2=data.t2, t3=data.tSend, t4 = recTime;
      ping = t4-t1 - (t3-t2);
      pingStack.push(ping)
      if (pingStack.length>stacksize) pingStack.shift()
    }

    if (data.type) switch (data.type) {
      case "SYN":
        send({type:"SYNACK"})
        break;
      case "SYNACK":
        // repeatedly send start condition to establish average ping time
        if (pingStack.length < stacksize) send({type:"SYN"})
        else {
          pingStack.shift() // The first is usually unrepresentative, throw away
          send({type:"ACK", seed})

          // wait for half the roundtrip time before starting the first frame
          nextFrame = performance.now() + avg(pingStack)/2
          setTimeout(processFrame, nextFrame - performance.now())
        }
        break;
      case "ACK":
        seed=data.seed
        nextFrame = performance.now()
        processFrame()
        break;
      case "input":

        if (rollbackInputs.length) {
          let myInput = rollbackInputs.shift()
          let yoInput = data.input
          loadRollbackState()

          if (yoInput.frame != myInput.frame) console.log("sync error waah",myInput.frame,yoInput.frame)

          processGameLogic(myInput,yoInput)
          storeRollbackState()

          // from here, run the rest of the buffer again
          yoInputLastDir = yoInput.dir

          for (let i=0;i<rollbackInputs.length;i++) {
            processGameLogic( rollbackInputs[i], {dir:yoInputLastDir} )
          }

        } else {
          yoInputs.push(data.input)
        }
        // check/adjust timing
        //input packet contains estimate until next frame
        let otherNextFrame = recTime -ping/2 + data.delay
        let frameDifference = (frameNumber-1 -data.input.frame)*frameLength
        let leadTime = nextFrame - otherNextFrame - frameDifference;
        leadStack.push(leadTime)
        if (leadStack.length>stacksize) leadStack.shift()

        break;

      case "debug":
        eval(data.eval)
        break;
    }
  }
}

CA=2; CB=15; CC=-4;

function objcopy(o){
  let copy = {}
  for (var a in o) {
    if (o.hasOwnProperty(a)) copy[a] = o[a];
  }
  return copy
}

for (let i=0;i<bufferSize;i++) {
  myInputs.push( { frame:frameNumber, dir:0 } )
  yoInputs.push( { frame:frameNumber, dir:0 } )
  frameNumber++
}
function processFrame(){

  let yoInput,myInput;
  if (yoInputs.length==0) {
    if (rollbackInputs.length>=10){
      //give up and delay
      nextFrame += 1
      if (connected) setTimeout(processFrame,1)
      return
    }
    if (rollbackInputs.length==0) {
      //commence rollback
      storeRollbackState()
    } 
    rollbackInputs.push(myInputs[0])

    yoInput = {frame:myInputs[0].frame, dir:yoInputLastDir}

  } else {
    yoInput = yoInputs.shift()
    yoInputLastDir = yoInput.dir
  }

  myInput = myInputs.shift()

  if (myInput.frame != yoInput.frame) {console.log("SYNC ERROR AHHH", myInput,yoInput); return}

  processGameLogic(myInput,yoInput)

  // take input from keyboard and add to stack
  myinput = { frame:frameNumber, dir:grabY }
  grabY = 0;
  myInputs.push( myinput )

  // timing drift correction - should this be before or after transmitting?
  if (leadStack.length==stacksize) {
    let lead = -avg(leadStack)
    if (lead>driftThreshold) { //we are running fast
       nextFrame += Math.min(lead*driftTrimFactor, frameLength)
    }
  }

  frameNumber++
  nextFrame += frameLength

  let now = performance.now()
  if (nextFrame<now-10) {
    //console.log('timing disrupted')
    nextFrame=now
  }
  let delay = nextFrame - now

  // send inputs to other
  send({type:"input", input:myinput, delay})

  if (enablesynctick) {
    if (now-lastAnimationFrame-synctick<CA || now-lastAnimationFrame-synctick>CB) synctick=CC;
    else synctick=0
    //else if (now-lastAnimationFrame>) synctick=0
  }

  if (connected) setTimeout(processFrame, delay + synctick)
}

function processGameLogic(myInput,yoInput){
  let oldlefty=left.y, oldrighty=right.y

  if (host) { processPlayer(left, myInput); processPlayer(right, yoInput); }
  else      { processPlayer(left, yoInput); processPlayer(right, myInput); }

  // calculate ball and stuff

  if (frameNumber==0) resetBall();

  let impulses = Math.ceil(ball.speed), step=1/impulses;
  for (let i=0;i<impulses;i++) {

    ball.x += ball.hspeed*step;
    ball.y += ball.vspeed*step;

    // bounce off top and bottom
    if (ball.y>h-10 || ball.y<10) ball.vspeed =-ball.vspeed;

    // check for face collision with paddle
    if (Math.round(ball.x-ballSize/2) == Math.round(left.x+paddleW/2-1) && vcollision(left)) {
      //reflect based on position
      ball.speed++
      let angle = Math.atan2(ball.y-left.y, 15)
      ball.hspeed = Math.cos(angle)*ball.speed
      ball.vspeed = Math.sin(angle)*ball.speed
      ball.x++
    }
    else if (Math.round(ball.x+ballSize/2) == Math.round(right.x-paddleW/2+1) && vcollision(right)) {
      ball.speed++
      let angle = Math.atan2(ball.y-right.y, -15)
      ball.hspeed = Math.cos(angle)*ball.speed
      ball.vspeed = Math.sin(angle)*ball.speed
      ball.x--
    }
    else if (ball.x+ballSize/2 < left.x+paddleW/2-1 && vcollision(left)) {
      ball.vspeed = -ball.vspeed
      if (ball.y<oldlefty) ball.y=left.y-paddleH/2-ballSize/2;
      else ball.y=left.y+paddleH/2+ballSize/2;
    }
    else if (ball.x+ballSize/2 > right.x+paddleW/2-1 && vcollision(right)) {
      ball.vspeed = -ball.vspeed
      if (ball.y<oldrighty) ball.y=right.y-paddleH/2-ballSize/2;
      else ball.y=right.y+paddleH/2+ballSize/2;
    }
  }

  if (ball.x<-ballSize) scoreRight++,resetBall()
  if (ball.x>w+ballSize) scoreLeft++,resetBall()
}

function processPlayer(p, input){
  p.y += input.dir;
  if (p.y > h-edgeGuard) p.y = h-edgeGuard;
  if (p.y <   edgeGuard) p.y = edgeGuard;
}

function vcollision(p){
  return (ball.y-ballSize/2 < p.y+paddleH/2 && ball.y+ballSize/2 > p.y-paddleH/2)
}

createBtn.onclick = function() {
  box1.innerHTML = '<h3>ID: '+ DC.host( setup ) +'</h3>';
  host=true;
}

joinBtn1.onclick = function(){
  box2.style.display='block'
  box1.style.display='none'
  conid.focus()
}
joinBtn2.onclick = function(){
  DC.join( parseInt(conid.value), setup );
  box2.innerHTML='Connecting...'
  return false
}

conid.value = "";



canvas.onmousedown=function(e){
  let sy = e.pageY
  e.preventDefault()
  e.stopPropagation()

  document.onmousemove=function(e){
    grabY += e.pageY - sy
    sy = e.pageY
  }
  document.onmouseup=function(e){
    document.onmouseup=null;
    document.onmousemove=null;
  }
}

touches=[];
canvas.ontouchstart=function(e){
  e.preventDefault();
  for (var i =e.changedTouches.length;i--;){
    var t={sy:e.changedTouches[i].pageY}
    touches[e.changedTouches[i].identifier]=t;
  }
}
canvas.ontouchmove=function(e){
  e.preventDefault();
  for (var i=e.changedTouches.length;i--;){
     var t=touches[e.changedTouches[i].identifier];
     grabY += (e.changedTouches[i].pageY - t.sy)
     t.sy=e.changedTouches[i].pageY;
  }
}


ggrid.strokeStyle="rgba(0,0,0,0.2)"
function drawgrid(x,y,w,h,xspace,yspace){
  ggrid.beginPath()
  for (let i=x;i<=x+w;i+=xspace) {
    ggrid.moveTo(i,y)
    ggrid.lineTo(i,y+h)
  }
  for (let j=y;j<=y+h;j+=yspace) {
    ggrid.moveTo(x,  j)
    ggrid.lineTo(x+w,j)
  }
  ggrid.stroke()
}

drawgrid(50,170,700,180,20,20)
drawgrid(50,370,700,50,10,10)
drawgrid(50,440,700,100,20,20)

ggrid.fillStyle="green";
ggrid.fillText("lag / lead (ms)",55,164)
ggrid.fillStyle="cyan";
ggrid.fillText("synctick",155,164)
ggrid.fillStyle="blue";
ggrid.fillText("buffer",55,364)
ggrid.fillStyle="red";
ggrid.fillText("ping (ms)",55,434)
ggrid.fillText("rollback buffer",155,364)
ggrid.fillStyle="orange";
ggrid.fillText("framesync (ms)",105,434)

ggrid.beginPath()
ggrid.moveTo(50,260)
ggrid.lineTo(750,260)
ggrid.moveTo(50,420)
ggrid.lineTo(750,420)
ggrid.moveTo(50,540)
ggrid.lineTo(750,540)
ggrid.stroke()

function newGraph(pos, col){
  var lastY=0;
  return function( y ){
    graph.strokeStyle=col
    graph.beginPath()
    graph.moveTo(needle,lastY +pos)
    graph.lineTo(needle+1,y +pos)
    graph.stroke()
    lastY=y
  }
}

needle=50
plotLead = newGraph(260,"green")
plotSnTc = newGraph(260,"cyan")
plotBuff = newGraph(420,"blue")
plotRolb = newGraph(420,"red")
plotPing = newGraph(540,"red")
plotSync = newGraph(540,"orange")
function doStats(t){
  let lead = leadStack.length? avg(leadStack) : 0;
  let ping = pingStack.length? avg(pingStack) : 0;

  graph.clearRect(needle,0,4,600)

  plotPing(-ping)
  plotBuff(-yoInputs.length*5)
  plotRolb(-rollbackInputs.length*5)
  plotLead(lead)
  plotSync((t-nextFrame)*5)
  plotSnTc(synctick*3)

  if (++needle>=750) needle=50


  let p="ping: " +ping.toFixed(3) + "ms\n"
       +"lead: " +lead.toFixed(3) + "ms\n"
       +"buffer: "+"\u25ae".repeat(yoInputs.length);
  if (yoInputs.length<bufferSize) p+="\u25af".repeat(bufferSize-yoInputs.length)
  p+= "\nframesync: "+(nextFrame-t).toFixed(3)+"ms\n"
  p+= "Display FPS: "+animFrameRate.toFixed(3)
  document.getElementById("stats").innerHTML = p
}



</script>